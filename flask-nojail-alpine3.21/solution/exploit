#!/usr/bin/env -S uv run --script
# -*- coding: utf-8 -*-
# This exploit template was generated via:
import re
import os
import requests

# Find flag by exact match or format
# log.success(find_flag(io.recvall()))
real_flag = open("./flag.txt", "r").readline().strip()
fake_flag = open("./flag-fake.txt", "r").readline().strip()
regx_flag = re.compile(r"gctf{.*}")
def find_flag(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    # Match real flag
    if real_flag in output:
        return real_flag
    # Match fake flag
    if fake_flag in output:
        return fake_flag
    # Match possible local flag
    with open("/flag.txt", "r") as local:
        locl_flag = local.readline().strip()
        if locl_flag in output:
            return locl_flag
    # Match regex flag
    m = regx_flag.search(output)
    if m is not None:
        return m.group(0)
    # Definitely no flag found
    return None

# Infra team here, always print the flag. Use find_flag(out) for convenience
# make solve expects ./flag.txt or ./flag-fake.txt in the output

protocol = os.environ.get("PROTOCOL", "http")
host = os.environ.get("HOST", "localhost")
port = int(os.environ.get("PORT", "1337"))

url = f"{protocol}://{host}:{port}"

print("[+] Running exploit", flush=True)

res = requests.get(f"{url}/flag")
body = res.content.decode()
flag = find_flag(body)
if flag:
    print(f"\033[93m[+] Flag: {flag}\033[0m", flush=True)
    exit(0)

print("[+] Flag could not be found", flush=True)
exit(255)
